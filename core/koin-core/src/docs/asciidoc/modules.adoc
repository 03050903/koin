== Koin Modules

By using Koin, you describe definitions in Koin modules. In this section, we will see how to declare, organize & link your modules.

=== What is a Koin Module?

A Koin module is a space to gather Koin definition. It's declared with the `module` function.

[source,kotlin]
----
val myModule = module {
    // Your definitions ...
}
----

=== Module's path

A module has a `path`, which represents a namespace to help organize Koin definitions.
The path is an optional parameter from the `module { }` function and its default value is root namespace.

.Modules with paths:
[source,kotlin]
----
// definitions in / (root) namespace
val aRootModule = module { ... }

// definitions in /org/sample namespace
val sampleModule = module("org.sample") { ... }
----

[NOTE]
====
The default namespace separator is "."
====

If several modules are declaring the same namespace, their definitions will be in the same namespace.

The Koin module's path is also a good way to separate definitions in Koin.

=== Inner modules

A module can also contains inner modules. An inner is a module declaration inside an
existing module declaration. It's also declared with `module` function, be an inner module
must specify a path.

.Module and an inner module:
[source,kotlin]
----
// definitions in / (root) namespace
val aModule = module {

    // definitions in /org/sample namespace
    module("org.sample") {

    }
}
----

The example above is the equivalent of previous section's example.

=== Linking modules & definitions

Components doesn't have to be necessarily in the same module. A module is a logical space to help you organize your definitions, and can depend on definitions from other
module. Definition are lazy, and then are resolved only when Koin container is started.

Let's take an example, with linked components in separate modules:

[source,kotlin]
----
// Give classes
// ComponentB <- ComponentA
class ComponentA()
class ComponentB(val componentA : ComponentA)

val moduleA = module {
    // Singleton ComponentA
    single { ComponentA() }
}

val moduleB = module {
    // Singleton ComponentB with linked instance ComponentA
    single { ComponentB(get()) }
}
----


[NOTE]
====
Koin does't have any import concept. Koin definitions are lazy: a Koin definition is started
with Koin container but is not instanciated. An instance is created only a request for its type
has been done.
====

We just have to declare list of used modules when we start our Koin container:

[source,kotlin]
----
// Start Koin with moduleA & moduleB
startKoin(listOf(moduleA,moduleB))
----

Koin will then resolve dependencies from all given modules.

=== Hierarchy & visibility

Visibility rule is quite simple: *child modules can see their parents, but not the inverse*. A definition from a child module,
can see definitions in parents modules. Modules can't share their definitions in divergent paths.

Let's take an example:

[source,kotlin]
----
// definitions in /
val rootModule = module {
    single { ComponentA() }
}
// definitions in /org
val orgModule = module("org") {
    single { ComponentB(...) }
}
// definitions in /org/sample
val sampleModule = module("org.sample") {
    single { ComponentC(...) }
}
// definitions in /org/demo
val demoModule = module("org.demo") {
    single { ComponentD(...) }
}
----

We have the following resolution possibility:

* `ComponentA can only see definitions from root (can only see `/`, can't see `ComponentB`, `ComponentC` & `ComponentD)
* `ComponentB` can see definitions from org & root (can see `/` and `/org` - can resolve ComponentA - can't see `ComponentC` & `ComponentD )
* `ComponentC` can see definitions from sample, org & root (can see `/`, `/org`, `/org/sample` - can resolve `ComponentA`, `ComponentB` - can't  see `ComponentD`)
* `ComponentD` can see definitions from demo, org & root (can see `/`, `/org`, `/org/demo` - can resolve ComponentA`, `ComponentB` - can't  see `ComponentC`)


=== Isolation: resolving definition from a path


