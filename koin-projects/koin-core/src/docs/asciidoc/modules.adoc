== Modules

By using Koin, you describe definitions in modules. In this section we will see how to declare, organize & link your modules.

=== What is a module?

A Koin module is a "space" to gather Koin definition. It's declared with the `module` function.

[source,kotlin]
----
val myModule = module {
    // Your definitions ...
}
----

=== Linking definitions between modules

Components doesn't have to be necessarily in the same module. A module is a logical space to help you organize your definitions, and can depend on definitions from other
module. Definitions are lazy, and then are resolved only when a a component is requesting it.

Let's take an example, with linked components in separate modules:

[source,kotlin]
----
// ComponentB <- ComponentA
class ComponentA()
class ComponentB(val componentA : ComponentA)

val moduleA = module {
    // Singleton ComponentA
    single { ComponentA() }
}

val moduleB = module {
    // Singleton ComponentB with linked instance ComponentA
    single { ComponentB(get()) }
}
----

[NOTE]
====
Koin does't have any import concept. Koin definitions are lazy: a Koin definition is started
with Koin container but is not instantiated. An instance is created only a request for its type
has been done.
====

We just have to declare list of used modules when we start our Koin container:

[source,kotlin]
----
// Start Koin with moduleA & moduleB
startKoin{
    modules(moduleA,moduleB)
}
----

Koin will then resolve dependencies from all given modules.

=== Linking modules strategies

*As definitions between modules are lazy*, we can use modules to implement different strategy implementation: declare an implementation per module.

Let's take an example, of a Repository and Datasource. A repository need a Datasource, and a Datasource can be implemented in 2 ways: Local or Remote.

[source,kotlin]
----
class Repository(val datasource : Datasource)
interface Datasource
class LocalDatasource() : Datasource
class RemoteDatasource() : Datasource
----

We can declare those components in 3 modules: Repository and one per Datasource implementation:

[source,kotlin]
----
val repositoryModule = module {
    single { Repository(get()) }
}

val localDatasourceModule = module {
    single<Datasource> { LocalDatasource() }
}

val remoteDatasourceModule = module {
    single<Datasource> { RemoteDatasource() }
}
----

Then we just need to launch Koin with the right combination of modules:

[source,kotlin]
----
// Load Repository + Local Datasource definitions
startKoin{
    modules(repositoryModule,localDatasourceModule)
}

// Load Repository + Remote Datasource definitions
startKoin{
    modules(repositoryModule,remoteDatasourceModule)
}
----

=== Visibility

Visibility rule is quite simple: every definition is visible in any module.

